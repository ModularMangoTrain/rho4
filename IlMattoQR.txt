QUICK R EFERENCE

F EATURES
AT MEGA 164P/PA 324P/PA 644P/PA 1284P
Flash
16K
32K
64K
128K
Boot
2K
4K
8K
8K
K
1K
2K
4K
EEPROM
SRAM
1K
2K
4K
16K
Architecture Harvard, RISC
131 (most single cycle)
Instructions
8-bit × 8-bit multiply (two cycles)
Registers 32×8-bit general purpose
Frequency 12MHz
Speed Up to 12 MIPS
Voltage 3.3V (CMOS Logic levels)
Symmetrical pin drive (40mA max.)
Output
VOH ≥ 2.53V, VOL ≤ 0.66V (@10mA)
Tri-state or internal pull-up (~35kΩ)
Input
VIH ≥ 1.98V, VIL ≤ 0.99V
Serial 2×UART, I2C, SPI
ADC (8 channels, 10-bit, 15kSPS)
Analogue
Analogue comparator
Timer/Counter 2×8-bit, 1×16-bit
PWM six (two for each timer/counter)
Programming JTAG, ISP, USB
Power Source USB, 3.3V, or external (3.6–6.0V)
Power Usage <5mA in native operation
Debug JTAG boundary scan & On-chip debug
Options SD Card (SPI interface), LiPo charger

Il Matto

1
2

Version: August 24, 2012
Steve R. Gunn
Electronics and Computer Science
University of Southampton
1

1

3-#:;'2<=+

Description
flash ROM
EEPROM
low fuse byte
high fuse byte
extended fuse byte
lock byte
RC oscillator cal. byte
three device sig. bytes

SPI UART
TXD
RXD
RTS
CTS

B

!"#$%&'()*+

4&6'7879+

2"&&$'01(!+

<&88/0'(-=+

read
write
verify

3&4'5657+

,"&&$'(-!+

.8#9:',;-+

!"#$%&'()*+

C

Intel Hex
Motorola S-record
raw binary (l. endian)
byte values (on CL)
auto-detect (input)
decimal (output)
hexadecimal (output)
octal (output)
binary (output)

PC7
PC6
PC5
PC4
PC3
PC2
PC1
PC0
PD7
PD6

D

Description

PB2

PB0

."/0$'(12+

Description

PB3

PB1

3"./$'4(5+

,&--./'0!(1+

PB4

PD5
PD4
PD3
PD2
PD1
PD0

SPI Bus Master clock input
SPI Bus Master Input/Slave Output
SPI Bus Master Output/Slave Input
SPI Slave Select input
Timer/Counter 0 Output Compare Match B Output
Analog Comparator Negative Input
Timer/Counter 0 Output Compare Match A Output
Analog Comparator Positive Input
External Interrupt 2 Input
Timer/Counter 1 External Counter Input
Divided System Clock Output
Timer/Counter 0 External Counter Input
USART0 External Clock Input/Output
Timer Oscillator pin 2
Timer Oscillator pin 1
JTAG Test Data Input
JTAG Test Data Output
JTAG Test Mode Select
JTAG Test Clock
2-wire Serial Bus Data Input/Output Line
2-wire Serial Bus Clock Line
Timer/Counter2 Output Compare Match A Output
Timer/Counter1 Input Capture Trigger
Timer/Counter2 Output Compare Match B Output
Timer/Counter1 Output Compare Match A Output
Timer/Counter1 Output Compare Match B Output
USART1 External Clock Input/Output
External Interrupt1 Input
USART1 Transmit Pin
External Interrupt0 Input
USART1 Receive Pin
USART0 Transmit Pin
USART0 Receive Pin

Notes: Each pin also has a pin change interrupt.
Each pin can also be configured as GPIO.
1

1

$0000
$0002
$0004
$0006
$0008
$000A
$000C
$000E
$0010
$0012
$0014
$0016
$0018
$001A
$001C
$001E
$0020
$0022
$0024
$0026
$0028
$002A
$002C
$002E
$0030
$0032
$0034
$0036
$0038
$003A
$003C

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
Notes:

RESET2
INT0
INT1
INT2
PCINT0
PCINT1
PCINT2
PCINT3
WDT
TIMER2_COMPA
TIMER2_COMPB
TIMER2_OVF
TIMER1_CAPT
TIMER1_COMPA
TIMER1_COMPB
TIMER1_OVF
TIMER0_COMPA
TIMER0_COMPB
TIMER0_OVF
SPI_STC
USART0_RX
USART0_UDRE
USART0_TX
ANALOG_COMP
ADC
EE_READY
TWI
SPM_READY
USART1_RX
USART1_UDRE
USART1_TX

AVR system reset condition3
External Interrupt Request 0
External Interrupt Request 1
External Interrupt Request 2
Pin Change Interrupt Request 0
Pin Change Interrupt Request 1
Pin Change Interrupt Request 2
Pin Change Interrupt Request 3
Watchdog Time-out Interrupt
Timer/Counter2 Compare Match A
Timer/Counter2 Compare Match B
Timer/Counter2 Overflow
Timer/Counter1 Capture Event
Timer/Counter1 Compare Match A
Timer/Counter1 Compare Match B
Timer/Counter1 Overflow
Timer/Counter0 Compare Match A
Timer/Counter0 Compare match B
Timer/Counter0 Overflow
SPI Serial Transfer Complete
USART0 Rx Complete
USART0 Data Register Empty
USART0 Tx Complete
Analog Comparator
ADC Conversion Complete
EEPROM Ready
2-wire Serial Interface
Store Program Memory Ready
USART1 Rx Complete
USART1 Data Register Empty
USART1 Tx Complete

1

If IVSEL bit in MCUCR is set, Interrupt Vectors will be moved
to the start of the Boot Flash Section.
If BOOTRST Fuse is set, it will jump to the Boot Loader address.
3
External Pin, Power-on, Brown-out, Watchdog, and JTAG Reset.
2

1

Default

AT MEGA 164P/PA
AT MEGA 324P/PA
AT MEGA 644P/PA
AT MEGA 1284P

I2C

ADC input channel 7
ADC input channel n
ADC input channel 0

Bit

Compatible devices

ISP

VCC
TCK SCK SCL SK
TDI MOSI SDA DO
TDO MISO SDA DI
TMS RST
— CS
G ND

ADC7
ADCn
ADC0
SCK
MISO
MOSI
SS
OC0B
AIN1
OC0A
AIN0
INT2
T1
CLKO
T0
XCK0
TOSC2
TOSC1
TDI
TDO
TMS
TCK
SDA
SCL
OC2A
ICP1
OC2B
OC1A
OC1B
XCK1
INT1
TXD1
INT0
RXD1
TXD0
RXD0

F USES & L OCK B ITS
Fuse

red
ora
ylw
grn
brn
blk

PA7
PAn
PA0
PB7
PB6
PB5

Interrupt Definition

7
6
5
4
3
2
1
0

 CKDIV8
ä CKOUT
ä SUT1
 SUT0
 CKSEL3
 CKSEL2
ä CKSEL1
 CKSEL0

Divide clock by 8
Enable clock output on pin PB1

Low

Lock

JTAG

 

   
   

A

I NTERRUPTS
No. Address1 Source

7
6
5
4
3
2
1
0

ä OCDEN
 JTAGEN
 SPIEN
ä WDTON
ä EESAVE
 BOOTSZ1
 BOOTSZ0
ä BOOTRST

Enable On Chip Debug
Enable JTAG
Enable Serial programming and Data Downloading
Watchdog timer always on
EEPROM memory is preserved through chip erase

High

USB
ISP
JTAG

Fuses

Interface

EEPROM

programmer
usbasp
c232hm
c232hm
device
m164p
m324p
m644p
m1284p
memtype
flash
eeprom
lfuse
hfuse
efuse
lock
calibration
signature
op
r
w
v
format
i
s
r
m
a
d
h
o
b

Flash

avrdude -c programmer -p device -U memtype :op :filename [:format]

Pin Name Description

Extended

P IN F UNCTIONS
Port

7
6
5
4
3
2
1
0

Lock

C ONFIGURATION

7
6
5
4
3
2
1
0

Name

Description

Select start-up time

Select Clock Source

Select Boot Size
Select Reset Vector

ä
ä
ä
ä
ä
ä BODLEVEL2
ä BODLEVEL1 Brown-out Detector trigger level
ä BODLEVEL0
ä
ä
ä
ä
ä
ä
ä
ä

BLB12
BLB11
BLB02
BLB01
LB2
LB1

ä means unprogrammed (1);  means programmed (0).
1

AVR C L IBRARY
<alloca.h>
<assert.h>
<ctype.h>
<errno.h>
<inttypes.h>
<math.h>
<setjmp.h>
<stdint.h>
<stdio.h>
<stdlib.h>
<string.h>
<avr/*.h>
<boot.h>
<cpufunc.h>
<eeprom.h>
<fuse.h>
<interrupt.h>
<io.h>
<lock.h>
<pgmspace.h>
<power.h>
<sfr_defs.h>
<signature.h>
<sleep.h>
<version.h>
<wdt.h>
<util/*.h>
<atomic.h>
<crc16.h>
<delay.h>
<delay_basic.h>
<parity.h>
<setbaud.h>
<twi.h>

I NTERRUPTS
Interrupts

Allocate space in the stack
Diagnostics
Character Operations
System Errors
Integer Type conversions
Mathematics
Non-local goto
Standard Integer Types
Standard IO facilities
General utilities
Strings

Bootloader Support Utilities
Special AVR CPU functions
EEPROM handling
Fuse Support
Interrupts
AVR device-specific IO definitions
Lockbit Support
Program Space Utilities
Power Reduction Management
Special function registers
Signature Support
Power Management and Sleep Modes
avr-libc version macros
Watchdog timer handling

Atomically and Non-Atomically Executed Code Blocks
CRC Computations
Convenience functions for busy-wait delay loops
Basic busy-wait delay loops
Parity bit generation
Helper macros for baud rate calculations
TWI bit mask definitions

¢

s,t ∈ {RESET, INT0, . . . , TIMER2_OVF, . . . , USART1_TX}
ISR(s_vect) { /* Handler code */ }
ISR(s_vect, ISR_NOBLOCK) { /* Handler code (interruptable) */ }
ISR(t_vect, ISR_ALIASOF(s_vect)); /* Shared handler */
sei(); /* Enable interrupts */
cli(); /* Disable all interrupts */
ISR(BADISR_vect) { /* Handle any undefined interrupt */ }
EMPTY_INTERRUPT(s_vect); /* Empty Handler */ }
ISR(s_vect, ISR_NAKED) { /* Handler code (no prolog/epilog) */
/* Save SREG if modified. */ reti(); }
¡
¢
External Interrupts n ∈ {0, 1, 2}, c ∈ { LL , D|D , H|L , L|H }
EIMSK &= ~_BV(INTn); /* Disable */
EICRA |= _BV(ISCn1) | _BV(ISCn0); /* c = L|H */
ISR(INTn_vect) { /* Handler code */ }
EIMSK |= _BV(INTn); /* Enable */
¡
¢
Pin Change Interrupts x ∈ {0, 1, 2, 3}, n ∈ {0, 1, . . . , 7}
ISR(PCINTx_vect) { /* Handler code */ }
PCICR = _BV(PCIEx); /* Enable Portx (0→A,1→B,2→C,3→D) */
PCMSKx &= _BV(n); /* Enable bit n on Portx */

I NTEGER T YPES
uint8_t
int8_t
uint16_t
int16_t
uintptr_t
uint32_t
int32_t
uint64_t
int64_t
typedef
typedef
typedef

8-bit unsigned int
(0 . . .
8-bit signed int
(-128 . . .
16-bit unsigned int
(0 . . .
16-bit signed int
(-32768 . . .
unsigned int pointer
(0x0000 . . .
32-bit unsigned int
(0 . . .
32-bit signed int
(-2147483648 . . .
64-bit unsigned int
(0 . . .
64-bit signed int
(-2 63 . . .
uint8_t byte;
(0 . . .
uint16_t word;
(0 . . .
uint32_t dword;
(0 . . .

1

U TILITIES
avr-gcc -mmcu=d -DF_CPU=f -Wall -Os prog.c -o prog.elf
Multiple source file project: Command to compile

avr-gcc -mmcu=d -DF_CPU=f -Wall -Os -c prog1.c -o prog1.o
Multiple source file project: Command to link

M EMORY
Program Memory

Boot Flash ROM
EEPROM

avr-objcopy -O ihex prog.elf prog.hex
Size

avr-size prog.elf

CPU Functions

#include <avr/cpufunc.h>
_NOP(); /* Execute a no operation (one clock cycle) */
_MemoryBarrier(); /* Do not cache memory data in registers */
Delays

#include <util/delay.h>
void _delay_us(double x); /* x microseconds */
void _delay_ms(double x); /* x milliseconds */
¡
¢
Redirect stdin, stdout and stderr (with assertions) to UARTn n ∈ {0, 1}
#define __ASSERT_USE_STDERR
#include <assert.h>
#include <stdio.h>
#include <avr/io.h>
void uputchar(char c, FILE *stream) {
if (c == ’\n’) uputchar(’\r’, stream);
loop_until_bit_is_set(UCSRnA, UDREn); UDRn = c; }
char ugetchar(FILE *stream) {
loop_until_bit_is_set(UCSRnA, RXCn); return UDRn;}
FILE uout = FDEV_SETUP_STREAM(uputchar, NULL, _FDEV_SETUP_WRITE);
FILE uin = FDEV_SETUP_STREAM(NULL, ugetchar, _FDEV_SETUP_READ);
init_uart(); stdout = &uout; stderr = &uout; stdin = &uin;
1

(16-bit)

Data Memory
32 Registers
64 I/O Registers
160 Ext I/O Reg.
.data vars
.bss vars
SRAM
heap ↓

0x0000

Application
Flash ROM

FLASHEND
(8-bit)

0x0000
E2END

avr-gcc -mmcu=d -DF_CPU=f -Wall -Os -o prog.elf prog1.o prog2.o . . .

avr-objdump -h -S prog.elf

¡

stack ↑

Input

DDRx = 0x00;
PORTx = 0xFF;
PORTx = 0x00;
value = PINx;
DDRx & = ~_BV(n);
PORTx | = _BV(n);
PORTx & = ~_BV(n);
if (PINx & _BV(n)) { ... }

FLASHEND
RAMEND
E2END
11
10
word* BOOTSZ
01
00
EEPROM

¡

0x1FFF
0x04FF
0x01FF
0x0080
0x0100
0x0200
0x0400

0x3FFF
0x08FF
0x03FF
0x0100
0x0200
0x0400
0x0800
¢

0x7FFF
0x10FF
0x07FF
0x0200
0x0400
0x0800
0x1000

(8-bit)

0x0000-0x001F
0x0020-0x005F
0x0060-0x00FF
0x0100
__bss_start
__heap_start
SP

-RAMEND

0xFFFF
0x40FF
0x0FFF
0x0200
0x0400
0x0800
0x1000

t ∈ {byte, word, dword, float}
#include <avr/eeprom.h>
t eeprom_read_t(t *p);
void eeprom_write_t(t *p, t value);
void eeprom_update_t(t *p, t value);
void eeprom_read_block(void *dst, const void *src, size_t n);
void eeprom_write_block(const void *src, void *dst, size_t n);
void eeprom_update_block(const void *src, void *dst, size_t n);
¡
¢
Program Memory
t ∈ {byte, word, dword, float}
#include <avr/pgmspace.h>
const float f PROGMEM = 3.14; /* Declare object in flash ROM */
const uint8_t data[] PROGMEM = {0x01,0x45,0x76,0xA6,...,0x61};
PGM_P s_ptr; /* Pointer to string in program space */
PGM_VOID_P g_ptr; /* Pointer to generic object in program space */
PSTR(s_ptr); /* Static pointer to string in program space */
t pgm_read_t(uint16_t byte_address);1
t pgm_read_t_far(uint32_t byte_address);
1

Data must be in lower 64KB for AT MEGA 1284P
1

Set 8-bits of port x as inputs
Enable pull-ups on input port x
Configure inputs as tri-state on port x
Read value of port x
Set bit n of port x as input
Enable pull-up on bit n of port x
Configure tri-state on bit n of port x
Test value of pin n on port x

DDRx =
PORTx =
PORTx =
PINx =
DDRx | =
PORTx | =
PORTx & =
PINx | =

0xFF;
0xFF;
0x00;
0xFF;
_BV(n);
_BV(n);
~_BV(n);
_BV(n);

Set 8-bits of port x as outputs
Set all output bits on port x high
Set all output bits on port x low
Toggle all output bits on port x high
Set bit n of port x as output
Set bit n of port x high
Set bit n of port x low
Toggle bit n of port x

0x0F;
0x0F;
0xF0;
PINx & 0xF0;

High 4-bits input, low 4-bits output
Set all output bits high
Set all output bits low
Read input bits on port x

Input/Output

DDRx =
PORTx | =
PORTx & =
value =

¡

¡

¢

n ∈ {0, 1, 2}, x ∈ {A, B}, m ∈ {0, 1, 2, 3}
n Bits
BOT
MAX
Internal Clock (F_CPU/d)
External Clock
0 8
0x00
0xFF
d ∈ {1, 8, 64, 256, 1024}
T0
1 16 0x0000 0xFFFF
d ∈ {1, 8, 64, 256, 1024}
T1
2 8
0x00
0xFF d ∈ {1, 8, 32, 64, 128, 256, 1024}
TOSC1
WGMn
OCRnx TOVn
COMnxm
Mode n ∈{0, 2} n=1
TOP Update Set m=0 m=1 m=2 m=3
Normal
0
0
MAX
IMD
MAX MM D|D
H|L L|H
2
4 OCRnA
CTC
–
12 ICRn
3
5
0xFF
MM
–
6 0x01FF
MM
PWM
H|L L|H
–
7 0x03FF BOT
TOP MM MM
(Fast)
7
15 OCRnA
D|D A 0 L|H 0 H|L
–
14 ICRn
D|D A
1
1
0xFF
MM
–
2 0x01FF
MM
PWM
–
3 0x03FF TOP
BOT MM MM
(PC)
5
11 OCRnA
D|D A ↑ H|L ↑ L|H
–
10 ICRn
MM ↓ L|H ↓ H|L
–
9 OCRnA
D|
DA
PWM
BOT
BOT MM
–
8
ICRn

MM

(PFC)

DDRB |= _BV(CT1A); /* Enable CT1 output A */
PORTB &= ~_BV(CT1A);/* Set output A low */
ICR1 = 1000; OCR1A = 950; /* Duty cycle 5% */
TCCR1A = 0; TCCR1B = _BV(WGM13); /* Mode 8: WGM1 = 0b1000 */
TCCR1A |= _BV(COM1A1) | _BV(COM1A0); /* PWM on Output A */
TCCR1B |= _BV(CS12) | _BV(CS10); /* F_TC1 = F_CPU/1024 */
¡
¢
Watchdog Timer T_WDT=2p×16ms, p ∈ {0, 1, . . . , 9}
#include <avr/wdt.h>
/* Disable Watchdog */
MCUSR &= ~_BV(WDRF); WDTCSR |= _BV(WDCE); WDTSCR = 0x00;
/* Enable 0.5s Watchdog (p=5) */
ISR(WDT_vect) { /* Handler Code */ }
WDTCSR |= _BV(WDCE); /* Four cycles to set-up WDTCSR */
WDTCSR = _BV(WDP2) | _BV(WDP0) | _BV(WDIE);
1

¢

¢

SPI F_SCK = F_CPU/d, d ∈ {2, 4, 8, 16, 32, 64, 128}
void init_spi_master(void) { /* out: MOSI, SCK, /SS, in: MISO */
DDRB = _BV(PB4) | _BV(PB5) | _BV(PB7);
SPCR = _BV(SPE) | _BV(MSTR) | _BV(SPI2X); /* F_SCK = F_CPU/2 */ }
void tx(uint8_t b) { SPDR = b; while(!(SPSR & _BV(SPIF))); }
void init_spi_slave(void) { /* out: MISO, in: MOSI, SCK, /SS */
DDRB = _BV(PB6); SPCR = _BV(SPE); /* Enable SPI */ }
uint8_t rx(void) { while(!(SPSR & _BV(SPIF))); return SPDR; }
¡

¢

I2C F_SCL = F_CPU/d, d =2(8+b 4p), b ∈ {0, 1, . . . , 255}, p ∈ {0, 1, 2, 3}
#include <util/twi.h>
void start(void) { TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
while(!(TWCR & _BV(TWINT))); }
void stop(void) { TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); }
void tx(uint8_t b) { TWDR = b; TWCR = _BV(TWINT) | _BV(TWEN);
while(!(TWCR & _BV(TWINT))); }
uint8_t rx(void) { TWCR = _BV(TWINT) | _BV(TWEN);
while(!(TWCR & _BV(TWINT))); return TWDR; }
TWBR = 0x34; TWSR = 0x00; /* F_SCL = F_CPU/120 */
start();
assert(TW_STATUS == TW_START);
tx(SLA | TW_READ); assert(TW_STATUS == TW_MR_SLA_ACK);
uint8_t b = rx();
assert(TW_STATUS == TW_MR_DATA_NACK);
start();
assert(TW_STATUS == TW_REP_START);
tx(SLA | TW_WRITE); assert(TW_STATUS == TW_MT_SLA_ACK);
tx(b);
assert(TW_STATUS == TW_MT_DATA_ACK);
stop();

1

¡

C OMMUNICATION

UART n ∈ {0, 1}, BAUD ∈ {1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
#define BAUD 57600
#include <util/setbaud.h>
void init_uart(void) { /* 8N1 */
UBRRnH = UBRRH_VALUE; UBRRnL = UBRRL_VALUE;
UCSRnA = USE_2X << U2Xn;
UCSRnB = _BV(RXENn) | _BV(TXENn);
UCSRnC = _BV(UCSZn0) | _BV(UCSZn1); }
void tx(uint8_t b) { while(!(UCSRnA & _BV(UDREn))); UDRn = b; }
uint8_t rx(void) { while(!(UCSRnA & _BV(RXCn))); return UDRn; }

1

T IMERS & C OUNTERS

AT MEGA 164P/PA 324P/PA 644P/PA 1284P

word*
byte*
byte*

¢

x ∈ {A, B, C, D}
PINx, PORTx, DDRx
Input, Output and Direction registers
¡
¢
Bit Manipulation n ∈ {0, 1, . . . , 7}, r ∈ {I/O Registers}
uint8_t value;
Declare value as an 8-bit byte
#define _BV(n) (1 << (n))
Bit Value
value = 0xFF;
Set all 8-bits of byte value
value = 0x00;
Clear all 8-bits of byte value
value = ~value;
Invert all bits of byte value
value |= _BV(n);
Set bit n of byte value
value &= ~_BV(n);
Clear bit n of byte value
if bit_is_set(r, n) { ... } Test if bit n of r is set
if bit_is_clear(r, n) { ... } Test if bit n of r is clear
loop_until_bit_is_set(r, n); Wait until bit n of r is set
loop_until_bit_is_clear(r, n); Wait until bit n of r is clear

Timers/Counters

d ∈ {atmega164p, atmega324p, atmega644p, atmega1284p}, f=12000000
Create target file

Port Registers

Output

255)
127)
65535)
32767)
0xFFFF)
4294967295)
2147483647)
2 64 -1)
2 63 -1)
255)
65535)
4294967295)

1

Single source file project: Command to compile and link

Disassembly

I NPUT /O UTPUT

¡

A NALOGUE
¡

¢

ADC n ∈ {0, 1, . . . , 7}, F_ADC = F_CPU/d, d ∈ {2, 4, 8, 16, 32, 64, 128}
ADCSRA |= _BV(ADPS2) | _BV(ADPS1); /* F_ADC = F_CPU/64 */
ADMUX = n; /* Select channel n */
ADMUX |= _BV(REFS0); /* AVCC reference */
ADMUX |= _BV(ADLAR); /* ADCH contains 8 MSBs */
ADCSRA |= _BV(ADATE); /* Automatic Trigger Enable */
ISR(ADC_vect) { /* ADCH & ADCL contain result */ }
ADCSRA |= _BV(ADEN); /* Enable ADC */
ADCSRA |= _BV(ADSC); /* Start Conversions */
ADCSRA |= _BV(ADIE); /* Enable interrupt */
¡
¢
Comparator A+ ∈ {AIN0, VBG }, A- ∈ {AIN1, PAn }, n ∈ {0, . . . , 7}, c ∈ { D|D , H|L , L|H }
ACSR &= ~_BV(ACBG); /* AIN0 Select */
ADCSRB &= ~_BV(ACME); /* AIN1 Select */
ACSR |= _BV(ACBG); /* Analog Comparator Bandgap Select (1.1V) */
ADCSRA &= ~_BV(ADEN); /* Disable ADC */
ADCSRB |= _BV(ACME); /* Analog Comparator Multiplexer Enable */
ADMUX = n; /* Select input PAn */
ACSR &= ~_BV(ACIE); /* Disable Interrupt */
ISR(ANALOG_COMP_vect) { /* Handler code */ }
ACSR |= _BV(ACIS1) | _BV(ACIS0); /* c = L|H */
ACSR |= _BV(ACIE); /* Enable Interrupt */

P OWER M ANAGEMENT
¡
¢
Sleep m ∈ {IDLE, ADC, PWR_DOWN, PWR_SAVE, STANDBY, EXT_STANDBY}

#include <avr/sleep.h>
set_sleep_mode(m); sleep_mode();
¡
¢
Power Saving u ∈ {adc, spi, timer0, timer1, timer2, twi, usart0, usart1, all}
#include <avr/power.h>
power_u_enable(); power_u_disable();
¡
¢
Frequency Scaling F_CPU=F_OSC/2p, p ∈ {0, 1, . . . , 8}
#include <avr/power.h>
void clock_prescale_set(clock_div_t p);
clock_div_t clock_prescale_get();
1

